\chapter{Análisis de la herramienta IsaacLab}

En este capítulo se presenta la herramienta IsaacLab, haciendo uso de la documentación oficial de IsaacLab \cite{isaaclab_doc}, el informe técnico \cite{mittal2025isaaclab} y la biblioteca de APIs \cite{isaaclab_api}. El objetivo es obtener una visión global de cómo funciona la herramienta, con el fin de comprender y crear entornos. A lo largo de él se estudiarán los conceptos básicos, los cuales se abarcarán en los próximos capítulos con ejemplos prácticos.

\section{¿Qué es IsaacLab?}
IsaacLab es una herramienta utilizada en el entrenamiento de robots en Python. Su principal objetivo es simplificar los procesos en este tipo de ejercicios \cite{isaaclab_doc}. IsaacLab está optimizado para su uso en GPUs, combinando la renderización de imágenes realistas con el motor de físicas \emph{PhysX} para construir simulaciones realistas \cite{mittal2025isaaclab}.

IsaacLab es una herramienta integrada dentro de IsaacSim. IsaacSim, a su vez, es una aplicación construida sobre NVIDIA Omniverse, la cual permite desarrollar, simular y probar robots controlados por IA en entornos virtuales \cite{Nvidia_isaac_nodate}. IsaacLab esta formada por un conjunto de herramientas utilizadas dentro del simulador IsaacSim. De este modo, pese a que se trabaja en su mayor parte con IsaacLab, se adquirirán en este capítulo algunos conceptos de IsaacSim.

Los principales incentivos para usar IsaacLab son \cite{isaaclab_doc}:
\begin{itemize}
    \item Modularidad: capacidad de modificar y añadir nuevos entornos, robots y sensores. Estos elementos se utilizan dentro de clases generalizadas, limitando las modificaciones en la estructura general.
    \item Código abierto: mantenimiento de un código abierto y libre para la comunidad. Esto permite una completa libertad para modificar cualquier código y adaptarlo a las necesidades del entorno.
    \item Gran cantidad de ejemplos y recursos: IsaacLab cuenta con un gran número de entornos, sensores y tareas preparadas para el entrenamiento. De este modo se parte de una base sobre la que construir las tareas personalizadas.
\end{itemize}

Por estos motivos, se ha escogido esta herramienta para realizar los entrenamientos. La principal desventaja de esta herramienta es la necesidad de utilizar un hardware específico, las tarjetas RTX de NVIDIA. Sin ellas no se pueden llevar acabo los ejercicios de aprendizaje, pues IsaacLab trabaja directamente sobre ellas. Esto permite maximizar el rendimiento de las tarjetas gráficas, pero limita el uso a la disposición de estos recursos.En este proyecto, se dispuso de estas tarjetas gracias a la cesión de un ordenador por parte del equipo MetaTool.

En conclusión, IsaacLab es una herramienta para realizar ejercicios de aprendizaje por refuerzo en IsaacSim. Con esto en mente, se presenta su estructura externa.

\section{Estrutura de la herramienta}%Lunes
\label{ap:structisaac}
La herramienta IsaacLab se centra en la construcción de los sistemas, los cuales luego se someten al aprendizaje. Estos reciben las acciones del agente (la red neuronal), procesando las recompensas y observaciones correspondientes \cite[Walkthrough, Enviroment Background Design]{isaaclab_doc}. Para la construcción de estos, IsaacLab utiliza la misma estructura que IsaacSim. Esta estructura define y gestiona los entornos. Se puede imaginar esta como una muñeca rusa, donde cada nivel contiene al resto (figura \ref{fig:lab_struct}).
\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.8\textwidth]{imagenes/labStruct.png}
    \caption{Estructura de la herramienta IsaacLab \cite{isaaclab_doc}.}
    \label{fig:lab_struct}
\end{figure}

El primer nivel consiste en la aplicación. Esta administra los recursos del sistema y es la encargada de lanzar y destruir la simulación \cite{isaaclab_doc}. La aplicación se puede gestionar a partir de la API \api{isaaclab.app} \cite{isaaclab_api}. Esta API se encarga de gestionar el lanzamiento de la aplicación, así como los distintos argumentos pertinentes a esta.

Esta aplicación contiene la simulación, la cual, como ya se ha mencionado, es creada y destruida por esta. Esta es la encargada de definir cómo funcionarán las físicas, el tiempo y la gravedad. Dicha simulación divide el ejercicio en múltiples instantes de tiempo, dividiendo las tareas de cálculo en subprocesos \cite{isaaclab_doc}. Esta, al igual que la aplicación, tiene su propia API, \api{isaaclab.sim} \cite{isaaclab_api}. Con esta, se definen parámetros como el tamaño de paso o la fuerza de la gravedad.

La simulación contiene todos los elementos relevantes a esta, los cuales se agrupan en el concepto de \emph{mundo} \cite{isaaclab_doc}. Este mundo se define por el origen de coordenadas, se toma como referencia para ubicar el resto de objetos. El mundo se estructura en dos componentes más: el escenario y la escena. El escenario, por un lado, proporciona un contexto geográfico dentro de la escena \cite{isaaclab_doc}. Es decir, permite utilizar dentro de las escenas un origen de coordenadas propio. La escena, por su parte, será la encargada de administrar los elementos que conforman el entorno. 

El entorno como tal estará organizado en un escenario (figura \ref{fig:lab_escena}) y será administrado por la escena. Es por esto que la escena tiene su propia API, \emph{isaaclab.scene} \cite{isaaclab_api}, la cual permite gestionar y obtener datos de todos los elementos del entorno. Estos se organizan en \emph{primarios}, elementos separados dentro de la organización del escenario que son importados a la escena a través de un archivo USD (figura \ref{fig:lab_escena}) \cite{isaaclab_doc}. USD, por su parte, es el lenguaje de descripción de robots y entornos \cite{isaaclab_usd}. En este trabajo no se maneja este lenguaje, pero sí se utilizan los ficheros de este tipo para importar los primarios.
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{imagenes/labScene.png}
    \caption{Organización de un escenario dentro de IsaacLab \cite{isaaclab_doc}.}
    \label{fig:lab_escena}
\end{figure}

IsaacLab, por lo tanto, está organizado en 5 conceptos fundamentales. Se asienta una referencia central, el mundo. Este contiene el escenario y la escena, los cuales organizan los entornos. Dicho mundo está contenido por la simulación, que define las propiedades de este. Por último, la simulación es gestionada por la aplicación. Esta es la estructura externa a los entornos, sobre la cual se asientan. A continuación, se presentarán las distintas maneras de construir los entornos.

\section{Arquitectura de entornos}
Teniendo en cuenta la estructura anterior, se procede ahora a estudiar la construcción de entornos. Se recuerda que los entornos son los encargados de recoger las acciones del cliente y procesar las observaciones y recompensas. Aparte de esta definición, se debe tener en cuenta el campo en el que se trabaja, la robótica. Por esto, el eje central de todos los entornos será el robot. Con todo esto en mente, se pueden definir los objetivos del diseño de entornos \cite{isaaclab_doc}:
\begin{enumerate}
    \item Definir el robot y las acciones.
    \item Definir los parámetros de la simulación.
    \item Definir la forma de clonado y el número de entornos.
    \item Calcular y entregar las acciones y recompensas
    \item Definir los estados absorbentes y los reinicios.
\end{enumerate}

Los entornos estarán constituidos por un robot y el resto de su entorno (objetos, obstáculos, efectos visuales, etc.). Sobre este entorno se definirán las acciones (asociadas directamente al robot), las recompensas y las observaciones. También se debe definir dentro de este entorno los estados absorbentes (finales). En algunas ocasiones el robot alcanzará un estado donde no será relevant continuar con el aprendizaje. En ese estado, se cerrará el episodio y se reiniciará el entorno. Por último, IsaacLab permite optimizar el tiempo de entrenamiento clonado los entornos. De este modo, en vez de tener un único entorno, se pueden tener múltiples entornos entrenando simultáneamente.

Para definir todos estos aspectos, existen dos principales maneras de programar los entornos:

\subsection{Direct Based}%Miércoles
La manera directa, como su propio nombre indica, es la más franca de las dos. Esta forma permite implementar todos los puntos antes mencionados en un mismo \emph{script}. Los entornos directos heredan de una clase \clase{DirectRLEnv}, dentro de la API \emph{isaaclab.envs}. Para programar el entorno entonces, se definen las funciones abstractas de esta clase. Seguidamente, la clase se envuelve en un \emph{wrapper} y se alimenta a una de las bibliotecas con los algoritmos de aprendizaje por refuerzo. Este proceso se verá en detalle en el apartado \ref{ap:entrenamiento}. A su vez, un ejemplo de este tipo de construcción se verá en el capítulo \ref{ch:arana}.
 
En la figura \ref{fig:lab_scheme_direct} se puede ver un esquema de las interacciones de la clase \clase{DirectRLEnv}, bajo el nombre \emph{Enviroment Scripting}. Esta clase se encarga de comunicar el entrono (la escena) y el agente. Por tanto, volviendo a la estructura del aprendizaje por refuerzo (\ref{ap:StrAR}), esta clase representaría las interacciones entre ambos elementos.
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{imagenes/labSchemeDirect.png}
    \caption{Diagrama para el modo directo de IsaacLab \cite{isaaclab_doc}.}
    \label{fig:lab_scheme_direct}
\end{figure}

En conclusión, la manera directa se centra en una única clase para la organización de las interacciones entre el entorno y el agente.

\subsection{Manager Based}%Miércoles
La manera basada en manejadores (\emph{Manager-based}), descompone las distintas partes de las interacciones en componentes individuales, los manejadores \cite{isaaclab_doc}. Estos manejadores aíslan distintos aspectos de la comunicación y gestión del agente y entorno, facilitando la organización de estos.

Entre los distintos manejadores están \cite{isaaclab_doc}:
\begin{itemize}
    \item Manejador de eventos (\clase{EventManager}): se encarga de definir y administrar aspectos del entorno. Esta clase es la encargada de ir cambiando parámetros de la escena durante los entrenamientos; de esta manera se pueden obtener entornos versátiles y variados durante un mismo entrenamiento. 
    \item Manejador de observaciones (\clase{Observation Manager}): se encarga de definir y gestionar las observaciones.
    \item Manejador de acciones (\clase{Action Manager}): se encarga de definir y gestionar las acciones.
    \item Manejador de recompensas(\clase{Reward Manager}): se encarga de definir y gestionar las recompensas.
    \item Manejador de objetivos (\clase{Command Manager}): se encarga de variar los objetivos del entrenamiento, siendo capaz de generar distintos valores en función de un rango.
    \item Manejador de finalización (\clase{Termination Manager}): se encarga de definir las condiciones en las cuales se pone fin al episodio.
\end{itemize}

Estos son los principales manejadores que se utilizarán en los entornos. Existe un manejador más, el manejador del currículum (\clase{Curriculum Manager}), encargado de crear una hoja de ruta para el entrenamiento. En este trabajo, al trabajar con objetivos concretos, no será necesario, bastando el manejador de órdenes para darle flexibilidad al ejercicio. Todos estos manejadores se alojan en una clase global, \clase{ManagerBasedRLEnv}, la cual se encarga de coordinarlos. Esta clase, al igual que la de modo directo, se encuentra dentro de la API \emph{isaaclab.envs} \cite{isaaclab_api}. Los manejadores, se desarrollarán como clases pertenecientes a esta clase global. Estas clases se encuentran dentro de la API \emph{isaaclab.managers} \cite{isaaclab_api}.

Más adelante, al entrar a estudiar el proyecto MetaTool, se estudiarán algunos ejemplos de esta forma de conformar entornos. El concepto más importante dentro de esta forma es el de término (\emph{Term}). Estos manejadores, se conforman de múltiples términos, los cuales descomponen aún más el ejercicio. Por ejemplo, para un manejador de observaciones con tres observaciones distintas (posición de las articulaciones, velocidad de las articulaciones y posición de un objeto) se tendrán tres términos distintos. De este modo, solo hace falta definir las observaciones individualmente en estos términos, el manejador después se encarga de entregársela al agente.

En el modo basado en manejadores entonces, las interacciones entre el agente y el entorno, así como su administración, se fragmenta en múltiples manejadores, facilitando la definición y la gestión de los distintos elementos. Esto se muestra en la figura \ref{fig:lab_scheme_manager}.
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{imagenes/labSchemeManager.png}
    \caption{Diagrama para el modo basado en manejadores de IsaacLab \cite{isaaclab_doc}.}
    \label{fig:lab_scheme_manager}
\end{figure}

Comparando ambas maneras de programar, el modo basado en manejadores permite tener un script más organizado, facilitando las modificaciones. Gracias a su formato de clases, tiene una gran capacidad modular; sin embargo, esta forma pierde parte del control. El modo directo, pese a ser más complicado de visualizar y gestionar, permite mantener un control sobre la definición de los elementos y como se estructuran. Ambos modos de programar son útiles; por sus facilidades el modo de manejadores se priorizará. En este trabajo, para tener primero una visión global de la construcción de entornos, se estudiará a fondo un caso directo. Una vez comprendida esta forma de trabajo, se continuará en MetaTool con el modo de manejadores. 

Ambas formas de programar hacen uso de dos conceptos fundamentales, las clases y los tensores. Las clases, tanto en el modo basado en manejadores como en el modo directo, son fundamentales; los entornos en ambas formas se definen a través de clases (\clase{DirectRLEnv} y \clase{ManagerBasedRLEnv}). Dentro de estas clases, se encontrará toda la información relevante del entorno, que en su mayoría estará definida como tensores \emph{Torch}. A continuación, se entrará un poco más en detalle sobre esta estructuración de la información.

\section{Estructuras de datos}%Viernes
Pese a que este trabajo se centre en la construcción de entornos, eso no significa que se deba perder referencia de la base matemática y los algoritmos de entrenamiento. Se debe poder definir correctamente todos los datos necesarios para que los algoritmos puedan trabajar correctamente. Es por esto que se realizó un estudio exhaustivo de la teoría del aprendizaje por refuerzo clásico y por lo que ahora se estudiará con detalle como se almacenan la información del entorno, para así poder comprender y definir las observaciones, recompensas y acciones correctamente.

Como se ha mencionado en el apartado anterior, existen dos estructuras principales de datos, las clases y los tensores. Referente a esto, cabe hacer una aclaración. Dentro del lenguaje de programación python hay multiples estructuras de datos relevantes: variables, métodos, etiquetas, etc. Sin embargo, estos conceptos son propios de python por lo que no son de interés en este trabajo. Sin embargo, dentro de IsaacLab, toman especial relevancia las clases (en especial las clases de configuración) y los tensores (trabajados con \emph{PyTorch}). A continuación, se presenta el motivo de esta relevancia y los aspectos más interesantes.

\subsection{Clases}
\label{ap:clasesconfigclass}
Las clases permiten agrupar datos y funcionalidades dentro de un objeto \cite[Tutorials, 9. Classes]{python_docs}. Es por tanto un elemento clave dentro de la estructura de datos de los entornos. No solo los manejadores y los entornos globales se estructuran en clases, sino los propios robots, los primitivos o las escenas, entre otros, también se estructuran en clases. Como se analizará al completo en los ejemplos, se accederá a todos los datos desde estas clases.

Las clases como tal, son un elemento básico de la programación orientada a objetos, por lo que se presupone un conocimiento básico sobre estas. Sin embargo, las clases dentro de IsaacLab se defines de una manera estandarizada, a través de otras clases \cite{isaaclab_doc}.

Las clases establecidas dentro de IsaacLab se definen a través de otra clase, las clases de configuración. En estas clases se definen los parámetros correspondientes a la clase que se quiere definir. Por ejemplo, si se quiere instanciar una clase \emph{InteractiveScene}, para crear una escena interactiva, se debe definir primero una clase \emph{InteractiveSceneCfg}. Estas clases de configuración, las cuales se verán en detalle en los ejemplos, se definen a través del decorador \emph{configclass}. Un decorador es una función que, en este caso, toma una clase como argumento y devuelve una clase modificada \cite[Glossary, decorator]{python_docs}. Este decorador prepara la clase para trabajarse como un argumento.

Dentro de las clases, se encontrarán datos relevantes al entorno. Por ejemplo, en una clase \emph{Articulation}, se encuentra una variable \emph{data}, que es a su vez es una clase \emph{ArticulationData}, la cual contiene información relevante al robot, como la posición de las articulaciones, \emph{Articulation.data.jointpos}. Esta variable final, podría expresarse como un vector sencillo, con dimensión igual al número de articulaciones. No obstante, al trabajar con múltiples entornos clonados en paralelo, esto no es eficaz; pues entonces se debería tener una clase para cada entorno. Para compactar la información, IsaacLab usa tensores de PyTorch. En el siguiente apartado se estudiará qué es un tensor, cómo se utilizan y porqué son importantes.

\subsection{Tensores: PyTorch}
Un tensor es un matriz multi-dimensional de datos de un mismo tipo \cite{pytorch_docs}. Un tensor tiene un número de dimensiones, llamadas ejes. Cada una de estas dimensiones tiene un tamaño, al que llamaremos tamaño de eje. Este tipo de dato permite organizar grandes cantidades de información en un mismo sitio. Por ejemplo, si se tienen 10 entornos, donde en cada uno se tiene un robot con una cámara, donde dicha cámara tiene una resolución de 800x400, se podría definir un tensor que guardase los valores RGB de estas cámaras. Dicho tensor tendría la siguiente forma: [10, 800, 400, 3]. Este tensor tendría 4 ejes, con tamaños respectivos de 10, 800, 400 y 3. De este modo, en una matriz de 4 dimensiones, se almacena de forma comprensiva el valor de todos los bits de las 10 cámaras. Cada eje, contiene a su eje inmediatamente inferior. El eje superior de este tensor sería el 10, siendo este el eje 0. Cada elemento de este eje, contiene el eje 1, con su tamaño de 800 elementos. Cada uno de esos elementos del eje 1, contiene un eje 2; y de igual manera con el eje 3 (o -1), siendo contenido por cada uno de los elementos del eje 2. Este tensor, por tanto, tendría 9.600.000 elementos. Cada uno de estos elementos, debe ser de un dato concreto. 

IsaacLab hace uso de estos tensores, mediante la herramienta PyTorch, para poder almacenar toda la información de los entornos en una sola clase. PyTorch, por su parte, es una librería centrada en la optimización de operaciones con tensores a través de GPU \cite{pytorch_docs}. IsaacLab utiliza esta librería dentro de sus librerías de algoritmos para el aprendizaje, por lo que todos los datos que se pretendan trabajar deberán manejarse mediante estos tensores. Esto incluye las observaciones, recompensas y acciones. Por esto, manejar correctamente los tensores es prioritario para la construcción de los entornos y sus interacciones con el agente. 

Dentro de los ejemplos, estudiaremos detenidamente las distintas operaciones que se vayan utilizando. No obstante, antes de empezar a estudiarlos, se debe estudiar como se entrenan finalmente los entornos, lo cual se verá en el próximo apartado.

\section{Entrenamiento de agentes}%Sábado
\label{ap:entrenamiento}

Una vez configurados los entornos y las interacciones, se debe entrenar el agente en él. El enfoque de este trabajo esta primera parte, por lo que no se entrará en detalle en el propio aprendizaje y sus algoritmos. IsaacLab provee de una serie de librerías, las cuales aportan los algoritmos de aprendizaje. Existen 4 librerías principales \cite{isaaclab_doc}:
\begin{itemize}
    \item SKRL \cite{serrano2023skrl}: se enfoca en la modularidad, simplicidad y transparencia. Es especialmente útil si se pretende modificar los algoritmos para experimentar o investigar.
    \item RSL-RL \cite{schwarke2025rslrl}: se crea pensando en robótica, manipulación y locomoción, siendo la más específica de las tres. Esto lleva también a una corta documentación y alta complejidad.
    \item RL-Games \cite{rl-games2021}: esta biblioteca busca la optimización en entrenamientos intensivos y multi-agentes; especialmente útil para entornos complejos.
    \item Stable-Baselines \cite{stable-baselines3}: de las 4 librerías, es la más documentada y con más comunidad y soporte, sin embargo, su presencia en ejemplos y sus capacidades son bastante limitadas.
\end{itemize} 

Teniendo en cuenta las características de todas estas librerías, la que mejor se adapta a este trabajo es la librería RSL-RL. Al no modificar ni entrar a estudiar la composición de su algoritmo, no afecta en gran medida la falta de documentación. Por otro lado, su especialización en robótica la hace tener el mejor rendimiento ente todas las bibliotecas \cite{isaaclab_doc}.

Para poder utilizar las bibliotecas, IsaacLab provee de un proceso para registrar y configurar agentes, \emph{gymnasium} \cite{towers2024gymnasium}. \emph{Gymnasium}, es una biblioteca de python en código abierto. Provee de una API para comunicar los algoritmos de aprendizaje con los entornos definidos. Para ello, registraremos la configuración de los entornos a través de esta API, creando asi una tarea con una configuración de agente asociada. De esta manera, al ejecutar los scripts de entrenamiento, \emph{train.py}, se puede seleccionar la tarea con el argumento \emph{--task} y realizar el entrenamiento.

El producto final del entrenamiento es la red neuronal parametrizada, la cual se guarda dentro del proyecto o la herramienta IsaacLab. Antes de poder utilizar esta red, se debe evaluar como se comporta; para lo cual tenemos distintos enfoques. En el próximo apartado se estudiará cada uno de ellos.

\section{Evaluación de agentes}%Sábado

Una vez obtenida la red neuronal, que vendría ser el agente entrenado, el siguiente objetivo consiste en implementar esta red neuronal en el robot real. Este proceso conforma un problema en su conjunto llamado \emph{sim2real} \cite{sim2realpaper}. Este problema se verá en detalle en el capítulo \ref{ch:sim2real}, donde integraremos alguna de las redes neuronales generadas en robots reales. Sin embargo, es prioritario para la seguridad del robot y de los operarios probar antes esta red neuronal en un entorno seguro. Por esto, se seguirá el siguiente procedimiento:
\begin{itemize}
    \item \emph{Sim-in-Sim}: Primero, mediante las herramientas de IsaacLab, se probará la red neuronal en la mismo sistema donde se ha implementado el aprendizaje.
    \item \emph{Sim2Sim}: Segundo, se realizará una simulación con herramientas externas para probar el comportamiento del robot en un entorno que tenga en cuenta las características reales de este.
    \item \emph{Sim2Real}: Por último, se implementará la red neuronal en el robot real.
\end{itemize}

El primer paso será el único que se realice con la herramienta IsaacLab. Esta provee en su biblioteca de algoritmos de un script para poder probar el resultado del aprendizaje, \emph{play.py}. Con este script se puede implementar la red neuronal sobre el mismo entorno y simulación entrenada. De este modo, se puede estudiar detenidamente las distintas recompensas y a través de ellas valorar el trabajo del robot.

Para el resto de pasos, se utilizarán otro tipo de herramientas y códigos, por lo que este también es la última utilización de la herramienta IsaacLab. Estudiando todas las utilidades de IsaacLab, se puede observar como abarca la gran parte del trabajo a realizar. Es por esto que antes de entrar a los ejemplos prácticos, se debe abstraer una idea general de la herramienta.

\section{Análisis Global}%Sábado

IsaacLab es una de las principales herramientas para el aprendizaje por refuerzo en la robótica. Su aplicación base, IsaacSim, está preparada para afrontar las dificultades que afronta la IA. Además, su utilización del potencial de las tarjetas GPU, las RTX, pese a limitar el uso a este hardware, permiten realizar ejercicios complejos de aprendizaje en poco tiempo.

La construcción de entornos dentro de esta herramienta, por otro lado, requiere de un conocimiento extenso de las API y librerías asociadas. Sin embargo, las dos formas de programación permiten libertad a la hora de desarrollar. Añadido a esto, una vez entendido el funcionamiento de la herramienta, construir y modificar entornos se vuelve fácil y rutinario. Gracias a esto, y a la gran cantidad de ejemplos, se encuentra que para la mayoría de ejercicios se puede trabajar sobre estos, adaptándolos al entorno a construir.

En el próximo capítulo, veremos un ejemplo de la programación directa. Se analizará cuidadosamente y se propondrán algunas mejoras.

